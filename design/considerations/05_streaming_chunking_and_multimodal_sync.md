# Streaming chunks, begin/end markers, and multimodal synchronization

## 1. Context and problem statement

E-commerce shopping assistants produce responses that combine multiple modalities: text, product cards, image carousels, and interactive elements (add-to-cart buttons). These modalities may be generated by different agents and must be rendered incrementally by the UI.

The streaming protocol must:
- Frame every response as a **chunk stream** with explicit begin/end markers.
- Support **multiple concurrent modality streams** within a single turn (e.g., text + product carousel).
- Correlate chunks across modalities so the UI can align rendering.
- Work identically for single-message and multi-chunk responses (unified protocol).
- Be compatible with the Event Bus (events, not raw byte streams).

**Constraints:**
- Latency-sensitive: first token/chunk should reach the UI within 200ms of generation.
- Must handle chunk loss or reordering (Event Bus provides ordered delivery per topic, but cross-topic ordering is not guaranteed).
- Must support checksum validation at the end of a stream.

## 2. Requirements coverage

| Requirement | Coverage |
|---|---|
| R5 — Async with streaming + chunk markers | Core: defines the streaming protocol. |
| R8 — Trajectory capture/replay | Every chunk event is stored; replay can reconstruct the stream. |

## 3. Options

### Option A — Raw byte streaming (SSE / WebSocket passthrough)

Agents produce raw byte streams; the framework passes them through to the UI.

**Pros:**
- Simple; no framing overhead.

**Cons:**
- No explicit begin/end markers; consumers must infer stream boundaries.
- No multimodal correlation; each stream is independent.
- Replay requires reconstructing streams from raw bytes.
- Not compatible with pub/sub Event Bus (events must be discrete messages).

### Option B — Chunk-framed protocol on the Event Bus (recommended)

Each agent response is a sequence of three event types: `stream.begin` → `stream.chunk[1..N]` → `stream.end`. These are discrete events on the Event Bus, enabling recording, replay, and multimodal correlation.

**Protocol definition:**

| Event | Fields | Description |
|---|---|---|
| `stream.begin` | `message_id`, `trace_id`, `agent_id`, `modality`, `expected_chunks` (optional hint), `correlation_group` | Opens a stream. |
| `stream.chunk` | `message_id`, `seq_no` (1-based), `payload`, `is_partial` (bool), `content_type` | Carries one chunk of content. |
| `stream.end` | `message_id`, `total_chunks`, `checksum` (SHA-256 of concatenated payloads), `final` (bool) | Closes the stream. |

**Multimodal synchronization:**
- All modalities within a single turn share a `correlation_group` (typically the turn's `trace_id` + a turn counter).
- The UI holds rendering slots for each `modality` and fills them as chunks arrive.
- If a `stream.end` is not received within the timeout, the UI renders what it has and displays a partial-response indicator.

**Pros:**
- Unified protocol: single-message responses use `N=1` (Begin + Chunk + End).
- Natural fit for the Event Bus (discrete events, ordered per topic).
- Full trajectory capture: every chunk is an event in the Trajectory Store.
- Multimodal alignment via `correlation_group` and `modality` tags.

**Cons:**
- Slightly higher overhead than raw streaming (event envelope per chunk).
- Requires sequence-number tracking and checksum validation at the consumer.

### Option C — Server-Sent Events (SSE) at the gateway, events internally

Use SSE between the Channel Gateway and the UI, but chunk-framed events internally.

**Pros:**
- SSE is well-supported by browsers for incremental rendering.

**Cons:**
- This is not mutually exclusive with Option B; SSE is a transport mechanism at the edge, while Option B defines the internal protocol.

**Recommendation: Use Option B internally + SSE at the Channel Gateway edge.** The Channel Gateway translates `stream.*` events into SSE for browser clients.

## 4. Decision drivers

| Driver | Weight | Favors |
|---|---|---|
| Multimodal synchronization | High | Chunk-framed (Option B) |
| Replay fidelity | High | Chunk-framed (Option B) |
| Event Bus compatibility | High | Chunk-framed (Option B) |
| Latency to first chunk | High | All options (low overhead) |
| Protocol simplicity | Medium | Raw streaming (Option A) |

## 5. Recommendation

**Recommended: Option B — Chunk-framed streaming on the Event Bus + SSE at the edge**

**Why:**
- Single unified protocol for all responses (streamed or not).
- Multimodal alignment is built into the protocol via `correlation_group` and `modality`.
- Every chunk is a Trajectory Store event — replay is trivial.
- SSE at the gateway is a thin translation layer.

**Risks / mitigations:**
| Risk | Mitigation |
|---|---|
| Chunk loss (consumer disconnects mid-stream) | `stream.end` includes `total_chunks` and `checksum`; consumer detects gaps and requests re-delivery or shows partial result. |
| High chunk count inflates event volume | Chunk size is tunable per agent (default: ~500 bytes for text). For large payloads (images), use a reference URL in the chunk payload. |
| Cross-modality ordering issues | Modalities are independent streams; UI renders each independently using `seq_no` ordering within a modality. No cross-modality ordering dependency. |
| Stream never closes (agent crash) | Agent Runtime emits `stream.end` with `final=false` on agent crash (or the Event Bus detects consumer death and publishes a synthetic `stream.end`). |

## 6. Required ADRs

- [ADR-0005: Streaming chunk protocol](../adr/ADR-0005-streaming-chunk-protocol.md) — this decision.

## 7. Diagrams

See [design/diagrams/03_streaming_chunks.md](../diagrams/03_streaming_chunks.md) for DataFlow and Activity diagrams.

## 8. References

- Confluent: [Event-Driven Multi-Agent Systems](https://www.confluent.io/blog/event-driven-multi-agent-systems/) — event-driven message patterns.
- Google Cloud: [Choose your agentic AI architecture components](https://docs.cloud.google.com/architecture/choose-agentic-ai-architecture-components) — streaming and response handling.
